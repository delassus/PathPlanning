/*
 * Trajectory.cpp
 *
 */

#include "Trajectory.h"
#include "Eigen/Eigen/Dense"
#include "TrajectoryCost.h"
#include <random>
#include <algorithm>

#include "constants.h"
#include "utils.h"
#include <algorithm>
#include <functional>
using namespace std;
using Eigen::MatrixXd;
using Eigen::VectorXd;

/* Template operator to add two trajectory vectors: this is useful to subtrac from vector trajectory 
 vector "delta" that specifies where we want to endup relatively to our goal.
 e.g our goal is the car in front of us, and we want to end up 20 meters behind it.
 */

template <typename T>
std::vector<T> operator+(const std::vector<T>& a, const std::vector<T>& b)
{
	assert(a.size() == b.size());

	std::vector<T> result;
	result.reserve(a.size());

	std::transform(a.begin(), a.end(), b.begin(),
			std::back_inserter(result), std::plus<T>());
	return result;
}

/* Constructor with the weights of each cost function */
Trajectory::Trajectory() {
	c_cost["time_diff_cost"] = CostFuncWeight(&time_diff_cost, 1);
	c_cost["s_diff_cost"] = CostFuncWeight(&s_diff_cost, 8);
	c_cost["d_diff_cost"] = CostFuncWeight(&d_diff_cost, 10000);
	c_cost["max_jerk_cost"] = CostFuncWeight(&max_jerk_cost, 100);
	c_cost["total_jerk_cost"] = CostFuncWeight(&total_jerk_cost, 1);
	c_cost["collision_cost"] = CostFuncWeight(&collision_cost, 100);
	c_cost["buffer_cost"] = CostFuncWeight(&buffer_cost, 1);
	c_cost["max_accel_cost"] = CostFuncWeight(&max_accel_cost, 100);
	c_cost["total_accel_cost"] = CostFuncWeight(&total_accel_cost, 1);
	c_cost["exceeds_speed_limit_cost"] = CostFuncWeight(&exceeds_speed_limit_cost, 10000);
	c_cost["stays_on_road_cost"] = CostFuncWeight(&stays_on_road_cost, 1000);
	tr_current_car_speed = 0;
}

/* Destructor */
Trajectory::~Trajectory() {

}

/*
 Calculates Jerk Minimizing Trajectory for start, end and T.
 */
vector<double> Trajectory::JMT(vector< double> start, vector <double> end, double T)
{


	MatrixXd A = MatrixXd(3, 3);
	A << T*T*T, T*T*T*T, T*T*T*T*T,
			3*T*T, 4*T*T*T,5*T*T*T*T,
			6*T, 12*T*T, 20*T*T*T;

	MatrixXd B = MatrixXd(3,1);
	B << end[0]-(start[0]+start[1]*T+.5*start[2]*T*T),
			end[1]-(start[1]+start[2]*T),
			end[2]-start[2];

	MatrixXd Ai = A.inverse();

	MatrixXd C = Ai*B;

	vector <double> result = {start[0], start[1], .5*start[2]};
	for(int i = 0; i < C.size(); i++)
	{
		result.push_back(C.data()[i]);
	}

	return result;

}

/*
 Finds the best trajectory according to WEIGHTED_COST_FUNCTIONS (global).

    arguments:
     start_s - [s, s_dot, s_ddot]

     start_d - [d, d_dot, d_ddot]

     target_vehicle - id of leading vehicle (int) which can be used to retrieve
       that vehicle from the "predictions" dictionary. This is the vehicle that
       we are setting our trajectory relative to.

     delta - a length 6 array indicating the offset we are aiming for between us
       and the target_vehicle. So if at time 5 the target vehicle will be at
       [100, 10, 0, 0, 0, 0] and delta is [-10, 0, 0, 4, 0, 0], then our goal
       state for t = 5 will be [90, 10, 0, 4, 0, 0]. This would correspond to a
       goal of "follow 10 meters behind and 4 meters to the right of target vehicle"

     T - the desired time at which we will be at the goal (relative to now as t=0)

     predictions - dictionary of {v_id : vehicle }. Each vehicle has a method
       vehicle.state_in(time) which returns a length 6 array giving that vehicle's
       expected [s, s_dot, s_ddot, d, d_dot, d_ddot] state at that time.

    return:
     (best_s, best_d, best_t) where best_s are the 6 coefficients representing s(t)
     best_d gives coefficients for d(t) and best_t gives duration associated w/
     this trajectory.
 */

TrajectoryModel Trajectory::PTG(const std::vector<double> &start_s, const std::vector<double> &start_d,
		std::vector<TrajectoryModel> &all_trjs, double T,const std::map<int, Vehicle> &predictions){

	double min_cost =  INFINITY;
	TrajectoryModel best;
	int count = 0;
	int best_count = 0;
	for(auto &trj: all_trjs){


		trj.s_coeff = JMT(start_s, trj.s_goal, trj.t);
		trj.d_coeff = JMT(start_d, trj.d_goal, trj.t);
	

		double cost = calculate_cost(trj, predictions);
		if(cost < min_cost){
			best =trj;
			min_cost = cost;
			best_count = count;
		}
		count++;
	}
	
	if(min_cost >= 100){
		best.TooRisky = true;
	}else{
		best.TooRisky = false;
	}
	
		calculate_cost(best, predictions);
	
	return best;
}

/* For each trajectory add up all the costs generated by the choices made in choosing the parameters */
double Trajectory::calculate_cost(const TrajectoryModel &trajectory,  const std::map<int, Vehicle> &predictions)
{
	double cost = 0;
	for (auto& measured : c_cost)
    {
		auto cost_of_this = measured.second;
		double new_cost = cost_of_this.weight * cost_of_this.cost_func(trajectory, predictions);
		cost += new_cost;
	}
	
	return cost;
}

/* Given a start state and an end goal generate a series of trajectories to choose from */
std::vector<TrajectoryModel> Trajectory::perturb_goals(const std::vector<double> &start_s, const std::vector<double> &start_d, double T,
		std::vector<double> &goal_s, std::vector<double> &goal_d,
		int target_vehicle, const std::vector<double> &delta,std::map<int, Vehicle> &predictions)
{

	
	static bool ResetClockNow = true;
	static vector<double> delta_s_distances={};
	if(ResetClockNow)
    {
		ResetClockNow = false;
		double min_dist = COLLISION_DISTANCE;
		double max_dist = SAFE_DISTANCE_BUFFER + 30;
		double d_s_dist = 5;

		double s_distance = min_dist;
		while(s_distance < max_dist)
        {
			delta_s_distances.push_back(-s_distance);
			s_distance += d_s_dist;
		}
	}


	std::vector<TrajectoryModel> all_trjs = {};

	if(target_vehicle == -1)
    {
		
		double gap_s = 0;
		while(gap_s <= 50)
        {
			vector<double> perturbed_goal_s = goal_s;
			perturbed_goal_s[0] = perturbed_goal_s[0] - gap_s;
			if(tr_current_car_speed >= 22.3){
				perturbed_goal_s[1] -= 2;
				cout<<"Slow down "<<endl;
			}
			all_trjs.push_back(TrajectoryModel(perturbed_goal_s,goal_d,T,goal_s,goal_d, T, gap_s));
			gap_s += 5;
		}

		return all_trjs;
	}


	const Vehicle &target = predictions[target_vehicle];
	vector<double> target_vehicle_state = target.state_in(T);

	for(const auto &delta_distance:delta_s_distances){



		vector<double> perturbed_goal_s = {target_vehicle_state[0] + delta_distance, target_vehicle_state[1]+delta[1],0};
        /* If s is negative set it to 5 */
		if(perturbed_goal_s[0] < 0)
        {
			perturbed_goal_s[0] = 5;
		}
        /* if s_dot is above the speed limit, cap it to the speed limit */
		if(perturbed_goal_s[1] > MAX_METERS_PER_SECOND_SPEED)
        {
			perturbed_goal_s[1] = MAX_METERS_PER_SECOND_SPEED;
		}
        /* In all cases take a small additional buffer to avoid breaking the speed limit */
		if(tr_current_car_speed >= FIFTY_MILES_PER_HOURS)
        {
			perturbed_goal_s[1] -= 2;
		}
		/* d is not randomized, ony s id randomized */
        vector<double> perturbed_goal_d = {target_vehicle_state[3] + delta[3],
				target_vehicle_state[4]+delta[4],target_vehicle_state[5]+delta[5]};
		
		goal_s= {target_vehicle_state[0] - SAFE_DISTANCE_BUFFER, perturbed_goal_s[1], perturbed_goal_s[2]};
		goal_d = perturbed_goal_d;
		all_trjs.push_back(TrajectoryModel(perturbed_goal_s,perturbed_goal_d,T,goal_s,goal_d, T, delta_distance));
	}
    /* Return a set of candidate trajectories where s is randomized */
	return all_trjs;
}


/* Generate a vector of potential goals and compute for each one of them a Minimum Jerk Trajectory */
TrajectoryModel Trajectory::pursue_goal(const std::vector<double> &start_s, const std::vector<double> &start_d, double T,
		std::vector<double> &goal_s, std::vector<double> &goal_d,  std::map<int, Vehicle> &predictions)
{
    //(1) Comute goals
	std::vector<TrajectoryModel> all_goals = perturb_goals(start_s, start_d, T, goal_s, goal_d, -1, {},predictions);
    //(2) Compute trajectories
    
    //(3) return (best_s, best_d, best_t) where best_s are the 6 coefficients representing s(t)
    //    best_d gives coefficients for d(t) and best_t gives duration associated with
    //    this trajectory.
    
	return PTG(start_s, start_d,all_goals, T,predictions);
}

/* A variant of the preceding function for the case where we want to follow a leading vehicle */
TrajectoryModel Trajectory::follow_vehicle(const std::vector<double> &start_s, const std::vector<double> &start_d, double T,
		int target_vehicle, const std::vector<double> &delta,  std::map<int, Vehicle> &predictions)
{
    /* Instead of being provided, goal_s and goal_d are empty vectors. The goal is given by the target vehicle plus a "delta" */
	std::vector<double> goal_s = {};
	std::vector<double> goal_d = {};
	std::vector<TrajectoryModel>  all_goals = perturb_goals(start_s, start_d, T, goal_s, goal_d, target_vehicle, delta,predictions);
	return PTG(start_s, start_d,all_goals, T,predictions);
}

/* Trajectory::keep_lane is executed when the path planner decides to stay in lane: it computes a trajectory for this specific case */
TrajectoryModel Trajectory::keep_lane(const std::vector<double> &start_s, const std::vector<double> &start_d,
		double T, std::map<int, Vehicle> &predictions)
{
    UTIL u;
	double s = start_s[0];
	double d = start_d[0];
	int target_car_id = -1;
	double distance = INFINITY;
    TrajectoryModel chosenTrajectory;
    //(1) Assume there is a leading vehicle in front of us within 350 meters distance
    //(2) Find where is the leading vehicle in our lane
    //(3) What is its identity
    //(4) At what distance from us is this leading vehicle
	
    for(auto &measured: predictions)
    {
		Vehicle &v = measured.second;
		if(u.which_lane(v.start_state[3]) != u.which_lane(d) || v.start_state[0] < s)
        {
			continue;
		}
		if((v.start_state[0] -s) < distance)
        {
			distance = v.start_state[0] -s;
			target_car_id = measured.first;
		}
	}
    
    // If there is leading vehicle within 350 meters in front of us compute "delta d" then compute a trajectory
	if(target_car_id !=-1)
    {
    
		double current_distance = predictions[target_car_id].start_state[0] - start_s[0];
		if (current_distance < SAFE_DISTANCE_BUFFER)
        {
            //Compute "delta d"
			double delta_d = u.get_lane_dist(u.which_lane(start_d[0])) - predictions[target_car_id].start_state[3];
			
            //Initialize a vector delta
            vector<double> delta = {0, 0, 0, delta_d, 0, 0};
			
            //Compute a trajectory that will bring us to our goal behind the leading vehidle at a distance specified by "delta"
            chosenTrajectory =  follow_vehicle(start_s, start_d, T, target_car_id, delta,  predictions);
			
            return chosenTrajectory;
		}
    }
    
    
    //If there is no leading vehicle within 350 meters in front of us:
    
    // Compute the 3 parameters for our trajectory
    
	//(1) Compute an acceleration
	double chosen_acceleration = (MAX_METERS_PER_SECOND_SPEED - start_s[1])/T;

	//(2) Compute s by estimating our position at time now + T
	vector<double> goal_s = {start_s[0]+ start_s[1]*T + 0.5*chosen_acceleration*T*T, MAX_METERS_PER_SECOND_SPEED, 0};

    //(3) Compute d which is our current d
	vector<double> goal_d = {u.get_lane_dist(u.which_lane(start_d[0])),0,0};
    
    //(4) compute the trajectory that will bring us to our goal
	chosenTrajectory =  pursue_goal(start_s, start_d, T, goal_s, goal_d,  predictions);
    return chosenTrajectory;
}
/* Compute a trajectory for the case when we want to change lane */
TrajectoryModel Trajectory::LANE_CHANGE(const std::vector<double> &start_s, const std::vector<double> &start_d,
		double T, std::map<int, Vehicle> &predictions, bool left)
    {
    UTIL u;
        
    /* Estimate our target lane */
	int target_lane_id = left ? u.which_lane(start_d[0]) - 1 :  u.which_lane(start_d[0]) + 1;
        
	double distance = INFINITY;
	int target_car_id = -1;
        
     //For each vehicle within distance
     // select only the case of vehicle in our target lane
	for(auto &measured: predictions)
    {
		Vehicle &v = measured.second;
		if(u.which_lane(v.start_state[3]) != target_lane_id || v.start_state[0] < start_s[0])
        {
            //vehicle not within distance or not in the target lane: skip the rest of the algorithm
			continue;
		}
		if((v.start_state[0] - start_s[0]) < distance)
        {
            //Vehicle within distance
			distance = v.start_state[0] -start_s[0];
			target_car_id = measured.first;
		}
	}
    
    //If we have found a vehicle within distance in our target lane
	if(target_car_id !=-1)
    {
        //Compute its distance from us
		double current_distance = predictions[target_car_id].start_state[0] - start_s[0];
        
        //If this distance is less than safety bounds
		if (current_distance < SAFE_DISTANCE_BUFFER)
        {
            //Compute target lane d
			double target_lane_dist = predictions[target_car_id].start_state[3];
            
			//Compute a lateral distance d to the vehicle for delta
            double delta_d = u.get_lane_dist(u.which_lane(target_lane_dist)) - target_lane_dist;
			
            //Initialize vector delta
            vector<double> delta = {0, 0,0,delta_d,0,0};
            
            //Compute a trajectory that will allow us to follow the leading vehicle from a distance of delta
			TrajectoryModel chosenTrajectory = follow_vehicle(start_s, start_d, T, target_car_id, delta,  predictions);
			
			return chosenTrajectory;
        }
    }

    //If there is no vehicle within distance we set ourselves our goals instead of adjusting the goals to the leading vehicle
    //Set an acceleration, an s and a d parameters
        
    //In this case we can accelerate smoothly to maximum speed
	double chosen_acceleration = (MAX_METERS_PER_SECOND_SPEED - start_s[1])/T;
	vector<double> goal_s = {start_s[0]+ start_s[1]*T + 0.5*chosen_acceleration*T*T, MAX_METERS_PER_SECOND_SPEED, 0};
	vector<double> goal_d = {u.get_lane_dist(target_lane_id),0,0};
    //Compute a trajectory
	TrajectoryModel chosenTrajectory = pursue_goal(start_s, start_d, T, goal_s, goal_d,  predictions);
	
	return chosenTrajectory;
}

